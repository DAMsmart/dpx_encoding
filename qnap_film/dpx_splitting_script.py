#!/usr/bin/env LANG=en_UK.UTF-8 /usr/local/bin/python3

'''
** ONLY ONE FOLDER PATH EVER DELIVERED TO SCRIPT FROM SHELL LAUNCH
Check if the folder needs renumbering using CSV entry generated by previous splits
Obtain size of folder, if within safe size move folder straight to encoding path
If folder too large, pass to one of four/five processing paths that generate splits
Renumber folder and output to CSV original and new folder numbering data, plus logs

Joanna White 2021
'''

import os
import sys
import shutil
import logging
import csv
import datetime

# Global vars
ERRORS = os.environ('CURRENT_ERRORS')
SCRIPT_LOG = os.environ('DPX_SCRIPT_LOG')
CSV_PATH = os.path.join(SCRIPT_LOG, 'splitting_document.csv')
PART_WHOLE_LOG = os.path.join(ERRORS, 'part_whole_search.log')
SPLITTING_LOG = os.path.join(SCRIPT_LOG, 'DPX_splitting.log')
TAR_PATH = os.path.join(os.environ('FILM_OPS'), os.environ('DPX_WRAP'))
RAWCOOKED_PATH = os.path.join(os.environ('FILM_OPS'), os.environ('DPX_COOK'))
TODAY = str(datetime.datetime.now())[:10]

# Setup logging
LOGGER = logging.getLogger('batch_transcode_h22_ffv1_v210')
HDLR = logging.FileHandler(os.path.join(os.environ('DPX_SCRIPT_LOG'), 'dpx_splitting_script.log'))
FORMATTER = logging.Formatter('%(asctime)s\t%(levelname)s\t%(message)s')
HDLR.setFormatter(FORMATTER)
LOGGER.addHandler(HDLR)
LOGGER.setLevel(logging.INFO)


def read_csv(dpx_sequence):
    '''
    Does fname entry exist in CSV, if yes retrieve data and return in tuple
    '''
    new_num = ''
    with open(CSV_PATH, newline='') as fname:
        readme = csv.DictReader(fname)
        for row in readme:
            orig_num = row['original']
            if str(orig_num) == str(dpx_sequence):
                new_num = row['new_number']
            return new_num
        fname.close()


def count_files(dirpath, division):
    '''
    Counts total DPX files in supplied sorted folder and returns the division totals
    Including first DPX in each block as lists, eg for single split:
    ['38411', '9602', '0084600.dpx', '0096003.dpx', '0105605.dpx', '0115207.dpx']
    Plus returns list of dictionary blocks of dpx numbers for move
    '''
    block_list = []
    dpx_list = []
    dpx_sequence = [name for name in os.listdir(dirpath) if name.endswith(('.dpx', '.DPX'))]
    file_count = len(dpx_sequence)
    dpx_sequence.sort()

    if division == '2':
        cut_point = int(file_count) // 2
        dpx_block1 = dpx_sequence[0]
        start_num = cut_point
        dpx_block2 = dpx_sequence[start_num]
        block_list = [file_count, cut_point, dpx_block1, dpx_block2]
        dpx_list.append({'block1': dpx_sequence[start_num:]})

    elif division == '3':
        cuts = int(file_count) // 3
        dpx_block1 = dpx_sequence[0]
        start_block3 = (cuts * 2)
        dpx_block2 = dpx_sequence[cuts]
        dpx_block3 = dpx_sequence[start_block3]
        block_list = [file_count, cuts, dpx_block1, dpx_block2, dpx_block3]
        dpx_list.append({'block1': dpx_sequence[cuts:start_block3]})
        dpx_list.append({'block2': dpx_sequence[start_block3:]})

    elif division == '4':
        cuts = int(file_count) // 4
        dpx_block1 = dpx_sequence[0]
        start_block2 = cuts
        start_block3 = (cuts * 2)
        start_block4 = (cuts * 3)
        dpx_block2 = dpx_sequence[start_block2]
        dpx_block3 = dpx_sequence[start_block3]
        dpx_block4 = dpx_sequence[start_block4]
        block_list = [file_count, cuts, dpx_block1, dpx_block2, dpx_block3, dpx_block4]
        dpx_list.append({'block1': dpx_sequence[start_block2:start_block3]})
        dpx_list.append({'block2': dpx_sequence[start_block3:start_block4]})
        dpx_list.append({'block3': dpx_sequence[start_block4:]})

    elif division == '5':
        cuts = int(file_count) // 5
        dpx_block1 = dpx_sequence[0]
        start_block2 = cuts
        start_block3 = (cuts * 2)
        start_block4 = (cuts * 3)
        start_block5 = (cuts * 4)
        dpx_block2 = dpx_sequence[start_block2]
        dpx_block3 = dpx_sequence[start_block3]
        dpx_block4 = dpx_sequence[start_block4]
        dpx_block5 = dpx_sequence[start_block5]
        block_list = [file_count, cuts, dpx_block1, dpx_block2, dpx_block3, dpx_block4, dpx_block5]
        dpx_list.append({'block1': dpx_sequence[start_block2:start_block3]})
        dpx_list.append({'block2': dpx_sequence[start_block3:start_block4]})
        dpx_list.append({'block3': dpx_sequence[start_block4:start_block5]})
        dpx_list.append({'block4': dpx_sequence[start_block5:]})

    return (block_list, dpx_list)


def fname_split(fname):
    '''
    Receive a filename extract part whole from end
    Return items split up
    '''
    name_split = fname.split('_')
    part_whole = name_split[2].split('of')

    return (name_split[0] + '_' + name_split[1] + '_', part_whole[0], part_whole[1])


def workout_division(arg, kb_size):
    '''
    Pass encoding argument and which is passed from shell launcher script
    Kilobyte calculated as byte = 1024
    '''
    division = ''
    kb_size = int(kb_size)

    # Size calculation for RAWcooked encoding sizes
    if 'rawcooked' in arg:
        if kb_size < 1503237:
            division = None
        elif 1503238 <= kb_size <= 3006476:
            division = '2'
        elif 3006477 <= kb_size <= 4509714:
            division = '3'
        elif 4509715 <= kb_size <= 6012954:
            division = '4'
        elif kb_size >= 6012954:
            LOGGER.warning("workout_division(): RAWcooked file is too large for DPX splitting:\n%s", kb_size)
            division = 'oversize'

    # Size calculation for tar encoding sizes
    elif 'tar' in arg:
        if kb_size < 1073741:
            division = None
        elif 1073742 <= kb_size <= 2147482:
            division = '2'
        elif 2147483 <= kb_size <= 3221224:
            division = '3'
        elif 3221225 <= kb_size <= 4294966:
            division = '4'
        elif 4294967 <= kb_size <= 5368709:
            division = '5'
        elif kb_size >= 5368710:
            LOGGER.warning("workout_division(): TAR file is too large for DPX splitting:\n%s", kb_size)
            division = 'oversize'
    '''
    if 'rawcooked' in arg:
        if kb_size < 1503238552:
            division = None
        elif 1503238553 <= kb_size <= 3006477107:
            division = '2'
        elif 3006477108 <= kb_size <= 4509715660:
            division = '3'
        elif 4509715661 <= kb_size <= 6012954214:
            division = '4'
        else kb_size >= 6012954215:
            LOGGER.warning("workout_division(): RAWcooked file is too large for DPX splitting:\n%s", kb_size)
            division = 'oversize'

    # Size calculation for tar encoding sizes
    elif 'tar' in arg:
        if kb_size < 1073741823:
            division = None
        elif 1073741824 <= kb_size <= 2147483648:
            division = '2'
        elif 2147483649 <= kb_size <= 3221225472:
            division = '3'
        elif 3221225473 <= kb_size <= 4294967296:
            division = '4'
        elif 4294967297 <= kb_size <= 5368709120:
            division = '5'
        else kb_size >= 5368709121:
            LOGGER.warning("workout_division(): TAR file is too large for DPX splitting:\n%s", kb_size)
            division = 'oversize'
    '''
    return division


def return_range_prior(fname, division):
    '''
    Receive file being processed, extract part whole data
    create all fnames that precede in that same range for update to CSV
    '''
    splt = fname.split('_')
    part_whole = splt[2].split('of')
    part = int(part_whole[0])
    whole = int(part_whole[1])
    division = int(division) - 1
    whole_count = whole + division
    change_list = []

    # Create new numbered files
    for count in range(1, whole_count + 1):
        new_name = splt[0] + '_' + splt[1] + '_' + str(count).zfill(2) + 'of' + str(whole_count).zfill(2)
        old_name = splt[0] + '_' + splt[1] + '_' + str(count).zfill(2) + 'of' + str(whole).zfill(2)

        # output old_name / new_name to CSV
        change_list.append({old_name: new_name})

    return change_list[:part - 1]


def folder_update_creation(dpx_sequence, division):
    '''
    Take DPX path and rename/create new folders based on division
    '''
    fname, part, whole = fname_split(dpx_sequence)
    part = int(part)
    whole = int(whole)
    change_list = []

    if division == '2':
        whole += 1
        dpx_seq_renumber = fname + str(part).zfill(2) + 'of' + str(whole).zfill(2)
        part += 1
        dpx_seq_new_folder = fname + str(part).zfill(2) + 'of' + str(whole).zfill(2)
        change_list.append({'dpx_sequence': dpx_sequence_renumber})
        change_list.append({'None': dpx_seq_new_folder})

    if division == '3':
        whole += 2
        dpx_seq_renumber = fname + str(part).zfill(2) + 'of' + str(whole).zfill(2)
        part += 1
        dpx_seq_new_folder1 = fname + str(part).zfill(2) + 'of' + str(whole).zfill(2)
        part += 1
        dpx_seq_new_folder2 = fname + str(part).zfill(2) + 'of' + str(whole).zfill(2)
        change_list.append({'dpx_sequence': dpx_sequence_renumber})
        change_list.append({'None': dpx_seq_new_folder1})
        change_list.append({'None': dpx_seq_new_folder2})

    if division == '4':
        whole += 3
        dpx_seq_renumber = fname + str(part).zfill(2) + 'of' + str(whole).zfill(2)
        part += 1
        dpx_seq_new_folder1 = fname + str(part).zfill(2) + 'of' + str(whole).zfill(2)
        part += 1
        dpx_seq_new_folder2 = fname + str(part).zfill(2) + 'of' + str(whole).zfill(2)
        part += 1
        dpx_seq_new_folder3 = fname + str(part).zfill(2) + 'of' + str(whole).zfill(2)
        change_list.append({'dpx_sequence': dpx_sequence_renumber})
        change_list.append({'None': dpx_seq_new_folder1})
        change_list.append({'None': dpx_seq_new_folder2})
        change_list.append({'None': dpx_seq_new_folder3})

    if division == '5':
        whole += 4
        dpx_seq_renumber = fname + str(part).zfill(2) + 'of' + str(whole).zfill(2)
        part += 1
        dpx_seq_new_folder1 = fname + str(part).zfill(2) + 'of' + str(whole).zfill(2)
        part += 1
        dpx_seq_new_folder2 = fname + str(part).zfill(2) + 'of' + str(whole).zfill(2)
        part += 1
        dpx_seq_new_folder3 = fname + str(part).zfill(2) + 'of' + str(whole).zfill(2)
        part += 1
        dpx_seq_new_folder4 = fname + str(part).zfill(2) + 'of' + str(whole).zfill(2)
        change_list.append({'dpx_sequence': dpx_sequence_renumber})
        change_list.append({'None': dpx_seq_new_folder1})
        change_list.append({'None': dpx_seq_new_folder2})
        change_list.append({'None': dpx_seq_new_folder3})
        change_list.append({'None': dpx_seq_new_folder4})

    return change_list


def return_range_following(fname, division):
    '''
    Receive file being processed, extract part whole data
    create all fnames that follow in that same range for update to CSV
    '''
    splt = fname.split('_')
    part_whole = splt[2].split('of')
    part = int(part_whole[0])
    whole = int(part_whole[1])
    division = int(division) - 1
    part_count = part + division
    whole_count = whole + division
    change_list = []

    # Create new numbered files
    for count in range(whole_count, part_count, -1):
        new_name = splt[0] + '_' + splt[1] + '_' + str(count).zfill(2) + 'of' + str(whole_count).zfill(2)
        count -= division
        old_name = split[0] + '_' + splt[1] + '_' + str(count).zfill(2) + 'of' + str(whole).zfill(2)
        # output old_name / new_name to list dict
        change_list.append({old_name: new_name})

    return change_list.reverse()  # returns order counting upward using reverse()


def main():
    '''
    ** ONLY ONE FOLDER PATH EVER DELIVERED TO SCRIPT FROM SHELL LAUNCH
    Check if the folder needs renumbering using CSV entry generated by previous splits
    Obtain size of folder, if within safe size move folder straight to encoding path
    If folder too large, pass to one of four/five processing paths that generate splits
    Renumber folder and output to CSV original and new folder numbering data, plus logs
    '''
    if len(sys.argv) < 4:
        LOGGER.warning("SCRIPT EXITING: Error with shell script input:\n %s", sys.argv)
        sys.exit()
    else:
        kb_size = sys.argv[1]
        dpx_path = sys.argv[2]
        encoding = sys.argv[3]  # 'rawcooked' or 'tar' passed from shell script
        if os.path.isdir(dpx_path):
            dpx_sequence = os.path.basename(dpx_path)
        else:
            LOGGER.info("The supplied sys.argv isn't a directory path %s. Script exiting", dpx_path)
            sys.exit()

        LOGGER.info("================== START Python3 DPX splitting script < %s > START ==================", dpx_sequence)

        ## Check if sequence has new numbering that should be updated
        new_num = read_csv(dpx_sequence)

        # Renumber folder and update dpx_path / dpx_sequence
        if len(new_num) > 5:
            try:
                new_path = renumber(dpx_path, new_num)
                LOGGER.info("Folder %s successfully renamed %s from CSV", dpx_sequence, new_num)
                LOGGER.info("DPX sequence path %s will be reconfigured to %s", dpx_path, new_path)
                dpx_path = new_path
                dpx_sequence = new_num
            except Exception as err:
                LOGGER.warning("Renumbering failed, exiting script to avoid processing incorrect files", err)
                sys.exit()
        # No renumbering needed
        else:
            LOGGER.info("Sequence %s not found in CSV so proceeding with processing:\n%s", dpx_sequence, dpx_path)

        ## Does this sequence need splitting?
        division = workout_division(encoding, kb_size)
        # Name preparations for folder splitting
        fname, part, whole = fname_split(dpx_sequence)
        path_split = os.path.split(dpx_path)
        root_path = path_split[0]

        ## No division needed, sequence is below 1.4TB
        if division is None:
            LOGGER.info("No splitting necessary for: %s\nMoving to encoding path for %s", dpx_path, encoding)
            if 'rawcooked' in encoding:
                LOGGER.info("Moving DPX sequence to RAWcooked path: %s", dpx_sequence)
                try:
                    shutil.move(dpx_path, RAWCOOKED_PATH)
                    LOGGER.info("Move completed to RAWcooked encoding path: %s", dpx_path)
                    LOGGER.info("Script exiting")
                    sys.exit()
                except Exception as err:
                    LOGGER.warning("Unable to move folder to RAWcooked path: %s", dpx_path)
                    sys.exit()
            elif 'tar' in encoding:
                LOGGER.info("Folder %s is not oversized.\nMoving DPX sequence to TAR path", dpx_path)
                try:
                    shutil.move(dpx_path, TAR_PATH)
                    LOGGER.info("Move completed to TAR encoding path: %s", dpx_path)
                    LOGGER.info("Script exiting")
                    sys.exit()
                except Exception as err:
                    LOGGER.warning("Unable to move folder to TAR path: %s", dpx_path)
                    sys.exit()
        ## Folder is larger than 5TB (TAR) / 5.6TB (RAWcooked) script exit
        elif 'oversize' in division:
            LOGGER.warning("OVERSIZE FILE: Too large for splitting script %s", dpx_path)
            LOGGER.warning("Script will exit, manual intervention needed for this file")
            LOGGER.critical("========= SCRIPT EXIT - MANUAL ASSISTANCE NEEDED =========")
            sys.exit()

        ## Folder requires splitting activities (can this function serve all divisions if lists are iterable?)
        elif '2' in division:
            LOGGER.info("Splitting folders with division %s necessary for: %s", division, dpx_path)

            # Find dpx_dirpath for all scan folders containing DPX files
            for root, dirs, files in os.walk(dpx_path):
                for file in files:
                    if file.endswith((".dpx", ".DPX")):
                        LOGGER.info("*** Folder path for splitting %s", root)

                        # Use root path to begin splitting processess
                        pre_foldername_list = return_range_prior(dpx_sequence, division)
                        folder_name_list_new = folder_update_creation(dpx_sequence, division)
                        post_folder_name_list = return_range_following(dpx_sequence, division)
                        print(pre_foldername_list)
                        print(folder_name_list_new)
                        print(post_folder_name_list)

                        '''
                        structure = os.path.join(new_folder_path, os.path.relpath(root, dpx_path))
                        try:
                            os.makedirs(structure, exists_ok=True)
                        except OsError:
                            LOGGER.warning("Exiting script: Unable to create new folder structure: %s", structure)
                            sys.exit()

                        # One new folder to be created
                        LOGGER.info("Folder %s will be divided into two", dpx_sequence)

                        success = make_dirs(dpx_path, new_split_sequence)
                        if success:
                            # Obtain: file_count, cuts, dpx_block1, dpx_block2
                            block_data = count_files(dpx_dirpath, division)
                            block_list = block_data[0]
                            dpx_list = block_data[1]
                            for key, value in dpx_list[0].items():
                                if 'block' in key:
                                    for dpx in v:
                                        dpx_to_move = os.path.join(root, dpx)
                                        dpx_destination = os.path.join(root_path, dpx_sequence_new_folder)
                                        shutil.move(dpx_path, new_dpx_path)
                        '''

def mass_move(dpx_path, new_path):
    '''
    Function just to move individual DPX file to new directory
    '''
    if os.path.exists(dpx_path) and os.path.exists(new_path):
        try:
            shutil.move(dpx_path, new_path)
        except Exception as err:
            LOGGER.warning("mass_move(): %s", err)
    else:
        LOGGER.warning("mass_move(): One of supplied paths does not exist:\n%s - %s", dpx_path, new_path)


def renumber(dpx_path, new_num):
    '''
    Split dpx_number from path and append new number for new_dpx_path
    Shutil move / or os.rename to change the name over.
    DPX path must be supplied without trailing '/'
    '''
    dpx_path = dpx_path.rstrip('/')
    path, dpx_sequence = os.path.split(dpx_path)
    new_path = os.path.join(path, new_num)
    try:
        os.rename(dpx_path, new_path)
        LOGGER.info("renumber(): Rename paths:\n%s changed to %s", dpx_path, new_path)
        return new_path
    except Exception as error:
        LOGGER.warning("renumber(): Unable to rename paths:\n%s NOT CHANGED TO %s", dpx_path, new_path, error)
        return False


def make_dirs(root_path, dpx_path, new_dpx_sequence):
    '''
    Makes new folder path directory for each split path
    One at a time, if multiple splits then this function to be
    called multiple times to create directory
    '''
    dpx_path = dpx_path.rstrip('/')
    path, old_sequence = os.path.split(dpx_path)
    new_dirpath = os.path.join(path, new_dpx_sequence)
    # os.path.relpath takes remaining folders from first path not in second path
    whole_dirpath = os.path.join(new_dirpath, os.path.relpath(root_path, dpx_path))

    try:
        os.makedirs(whole_dirpath, exist_ok=True)
        LOGGER.info("make_dirs(): New path mkdir: %s", whole_dirpath)
        return whole_dirpath
    except Exception as error:
        print("Unable to make new directory {}".format(whole_dirpath))
        LOGGER.warning("make_dirs(): Unable to make new directory: %s", whole_dirpath, error)
        return None


def write_csv(fname, new_fname, dpx, cut):
    '''
    Write filename and changed filenames following splitting to CSV which maps
    the alterations, but also allows for late comers to be updated if they are
    not processed at the time of the splitting.
    '''
    length = len(dpx[:-4])
    dpx_num = int(dpx[:-4]) + int(cut)
    dpx_end = (str(dpx_num).zfill(length) + '.dpx')

    with open(CSV_PATH, 'a', newline='') as csvfile:
        if len(fname) > 0:
            data = [fname, new_fname, dpx, dpx_end, TODAY]

        datawriter = csv.writer(csvfile)
        datawriter.writerow(data)
        csvfile.close()


def splitting_log(fname, size, division, block_list, folders=None):
    '''
    Output ob_num to part_whole_search.log in DPX Errors folder. Used by various encoding scripts
    to avoid moving files if their numbers are present in the list. Original name ONLY to be added
    to this list. Handles if on_num already listed, or if log removed, replaces and appends number.
    '''
    if folders is None:
        folders = []
        LOGGER.warning("splitting_log(): No folders data received")

    with open(SPLITTING_LOG, 'a') as log:
        LOGGER.info("splitting_log(): Filename splitting data < %s > appending to splitting log", fname)
        log.write("======== SPLITTING: {} ======== SIZE: {} KB ======== DATE: {}\n".format(fname, size, TODAY))
        log.write("Folder needs dividing into {} additional folders\n".format(division))
        log.write("New folder numbers generated for original folders:\n")
        for key, val in folders.items():
            log.write("Original: {} - New folder: {}\n".format(key, val))
        log.write("New DPX sequences created with following data:\n")
        log.write(block_list)
        log.write("-------------------------------------------------------------------------")
        log.close()


def part_whole_log(fname):
    '''
    Write the specific splitting information to a log file (in name of folder originally split)
    Including date, original folder name, updated folder name and new folder name(s).
    Each DPX start and end file per sequence.
    '''
    ob_num = fname[:-7]

    with open(PART_WHOLE_LOG, 'a+') as log:
        log.seek(0)
        data = log.read()
        for line in data:
            if ob_num in str(line):
                LOGGER.info("part_whole_log(): Object number %s already in part whole search log, skipping", ob_num)
            else:
                if len(data) > 0:
                    log.write("\n")
                LOGGER.info("part_whole_log(): Object number %s appended to part_whole log in errors folder", ob_num)
                log.write(ob_num)
        log.close()


if __name__ == '__main__':
    main()
